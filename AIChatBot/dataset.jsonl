{"messages": [{"role": "system", "content": "Ти асистент, який пояснює патерни проєктування."}, {"role": "user", "content": "Розкажи про патерн \"Абстрактна фабрика\"."}, {"role": "assistant", "content": "Проблема:\nСтворити сімейство взаємопов’язаних або взаємозалежних об’єктів (без специфікації конкретних класів).\n\nРішення:\nСтворити абстрактний клас, в якому оголошений інтерфейс для створення конкретних класів.\n\nПереваги:\n- Ізолює конкретні класи.\n- Оскільки \"Абстрактна фабрика\" інкапсулює відповідальність за створення класів і сам процес їхнього створення, то вона ізолює клієнта від деталей реалізації класів.\n- Спрощена заміна \"Абстрактної фабрики\" тому, що вона використовується у додатку тільки один раз при інстанціюванні."}]}
{"messages": [{"role": "system", "content": "Ти асистент, який пояснює патерни проєктування."}, {"role": "user", "content": "Розкажи про патерн \"Будівельник\"."}, {"role": "assistant", "content": "Проблема:\nВідділити конструювання складного об’єкту від його представлення, так щоб в результаті одного і того ж конструювання могли утворюватися різні представлення. Алгоритм створення складного об’єкта не повинен залежати від того, з яких частин складається об’єкт і як вони стикуються між собою.\n\nРішення:\n\"Клієнт\" створює об’єкт – розпорядник \"Директор\" і конфігурує його об’єктом – \"Будівельником\". \"Директор\" повідомляє \"Будівельника\" про те, що слід побудувати чергову частину \"Продукту\". \"Будівельник\" обробляє запити \"Директора\" і додає нові частини до \"Продукту\", потім \"Клієнт\" забирає \"Продукт\" у \"Будівельника\".\n\nПереваги:\n- Об’єкт \"Будівельник\" надає об’єкту \"Директор\" абстрактний інтерфейс для конструювання \"Продукту\", за яким може приховати представлення і внутрішню структуру продукту, і, крім цього, процес збірки \"Продукту\".\n- Для зміни внутрішнього представлення \"Продукту\" достатньо визначити новий вид \"Будівельника\"."}]}
{"messages": [{"role": "system", "content": "Ти асистент, який пояснює патерни проєктування."}, {"role": "user", "content": "Розкажи про патерн \"Фабричний Метод\"."}, {"role": "assistant", "content": "Проблема:\nВизначити інтерфейс для створення об’єкта, але залишити підкласам рішення про те, який клас інстанціювати, тобто, делегувати інстанціювання підкласам.\n\nРішення:\nАбстрактний клас \"Творець\" оголошує Фабричний Метод, який повертає об’єкт типу \"Продукт\" (абстрактний клас, що визначає інтерфейс об’єктів, які створюються фабричним методом). \"Творець\" також може визначити реалізацію за замовчуванням Фабричного Методу, який повертає \"Конкретний Продукт\". \"Конкретний Творець\" заміщує Фабричний Метод, що повертає об’єкт \"Конкретний Продукт\". \"Творець\" покладається на свої підкласи у визначенні Фабричного Методу.\n\nПереваги:\n- Позбавляє проектувальника від необхідності вбудовувати в код залежні від додатку класи.\n\nНедоліки:\n- Виникає додатковий рівень підкласів."}]}
{"messages": [{"role": "system", "content": "Ти асистент, який пояснює патерни проєктування."}, {"role": "user", "content": "Розкажи про патерн \"Прототип\"."}, {"role": "assistant", "content": "Проблема:\nСистема не повинна залежати від того, як у ній створюються, компонуються і представляються об’єкти.\n\nРішення:\nСтворювати нові об’єкти з допомогою патерна - прототипу. \"Прототип\" оголошує інтерфейс для клонування самого себе. \"Клієнт\" створює новий об’єкт, звертаючись до \"Прототипу\" з запитом клонувати \"Прототип\".\n\nПереваги:\n- Створює глибоку копію комплексної ієрархії об'єктів.\n- Зменшення навантаження ініціалізації.\n- Багаторазові можливості — оптимізовані зусилля щодо кодування.\n- Спрощений процес копіювання об'єктів.\n\nНедоліки:\n- Додаткові витрати на розробку.\n- Потребує уважності і точності при глибокому копіюванні."}]}
{"messages": [{"role": "system", "content": "Ти асистент, який пояснює патерни проєктування."}, {"role": "user", "content": "Розкажи про патерн \"Одинак\"."}, {"role": "assistant", "content": "Проблема:\nНеобхідний лише один екземпляр спеціального класу, різні об’єкти повинні звертатися до цього екземпляру через єдину точку доступу.\n\nРішення:\nСтворити клас і визначити статичний метод класу, який повертає цей єдиний об’єкт.\n\nПереваги:\n- Гарантує наявність єдиного екземпляра класу.\n- Надає глобальну точку доступу до нього.\n- Реалізує відкладену ініціалізацію об’єкта-одинака.\n\nНедоліки:\n- Порушує принцип єдиного обов’язку класу.\n- Маскує поганий дизайн.\n- Проблеми багатопоточності.\n- Вимагає постійного створення Mock-об’єктів при юніт-тестуванні."}]}
{"messages": [{"role": "system", "content": "Ти асистент, який пояснює патерни проєктування."}, {"role": "user", "content": "Розкажи про патерн \"Адаптер\"."}, {"role": "assistant", "content": "Проблема:\nНеобхідно забезпечити взаємодію несумісних інтерфейсів або створити єдиний стійкий інтерфейс для декількох компонентів з різними інтерфейсами.\n\nРішення:\nКонвертувати вихідний інтерфейс компонента до іншого виду за допомогою проміжного об’єкта – адаптера, тобто, додати спеціальний об’єкт з спільним інтерфейсом у рамках даного додатку і перенаправити зв’язки від зовнішніх об’єктів до цього об’єкту – адаптеру.\n\nПереваги:\n- Відокремлює та приховує від клієнта подробиці перетворення різних інтерфейсів.\n\nНедоліки:\n- Ускладнює код програми внаслідок введення додаткових класів."}]}
{"messages": [{"role": "system", "content": "Ти асистент, який пояснює патерни проєктування."}, {"role": "user", "content": "Розкажи про патерн \"Міст\"."}, {"role": "assistant", "content": "Проблема:\nПотрібно відділити абстракцію від реалізації так, щоб і те і інше можна було змінювати незалежно. При використанні наслідування реалізація жорстко прив’язується до абстракції, що утруднює незалежну модифікацію.\n\nРішення:\nПомістити абстракцію і реалізацію в окремі ієрархії класів.\n\nПереваги:\n- Дозволяє будувати платформо-незалежні програми.\n- Приховує зайві або небезпечні деталі реалізації від клієнтського коду.\n- Реалізує принцип відкритості/закритості.\n\nНедоліки:\n- Ускладнює код програми внаслідок введення додаткових класів."}]}
{"messages": [{"role": "system", "content": "Ти асистент, який пояснює патерни проєктування."}, {"role": "user", "content": "Розкажи про патерн \"Компонувальник\"."}, {"role": "assistant", "content": "Проблема:\nЯк обробляти групу або композицію структур об’єктів одночасно?\n\nРішення:\nВизначити класи для композитних і атомарних об’єктів таким чином, щоб вони реалізовували один і той же інтерфейс.\n\nПереваги:\n- Спрощує архітектуру клієнта при роботі зі складним деревом компонентів.\n- Полегшує додавання нових видів компонентів.\n\nНедоліки:\n- Створює занадто загальний дизайн класів."}]}
{"messages": [{"role": "system", "content": "Ти асистент, який пояснює патерни проєктування."}, {"role": "user", "content": "Розкажи про патерн \"Декоратор\"."}, {"role": "assistant", "content": "Проблема:\nПокласти додаткові обов’язки (прозорі для клієнтів) на окремий об’єкт, а не на клас в цілому.\n\nРішення:\nДинамічно додати об’єкту нові обов’язки не застосовуючи при цьому породження підкласів (наслідування). \"Компонент\" визначає інтерфейс для об’єктів, на які можуть бути динамічно покладені додаткові обов’язки, \"Конкретний Компонент\" визначає об’єкт, на який покладаються додаткові обов’язки, \"Декоратор\" – зберігає посилання на об’єкт \"Компонент\" і визначає інтерфейс, що відповідає інтерфейсу \"Компонент\". \"Конкретний Декоратор\" покладає додаткові обов’язки на компонент.\n\nПереваги:\n- Більша гнучкість, ніж у спадкування.\n- Дозволяє додавати обов’язки «на льоту».\n- Можна додавати кілька нових обов’язків одразу.\n- Дозволяє мати кілька дрібних об’єктів, замість одного об’єкта «на всі випадки життя».\n\nНедоліки:\n- Важко конфігурувати об’єкти, які загорнуто в декілька обгорток одночасно.\n- Велика кількість крихітних класів."}]}
{"messages": [{"role": "system", "content": "Ти асистент, який пояснює патерни проєктування."}, {"role": "user", "content": "Розкажи про патерн \"Фасад\"."}, {"role": "assistant", "content": "Проблема:\nЯк забезпечити уніфікований інтерфейс з набором розрізнених реалізацій чи інтерфейсів, наприклад, з підсистемою, якщо небажаним є високе зв’язування з цією підсистемою або реалізація підсистеми може змінитися?\n\nРішення:\nВизначити одну точку взаємодії з підсистемою – фасадний об’єкт, що забезпечує загальний інтерфейс з підсистемою, та покласти на нього обов’язки з взаємодії з її компонентами.\n\nПереваги:\n- Ізолює клієнтів від компонентів складної підсистеми.\n\nНедоліки:\n- Фасад ризикує стати божественим об’єктом, прив’язаним до всіх класів програми."}]}
